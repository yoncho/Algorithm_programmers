#1차 코드
#문제 : 전화번호부에 적힌 전화번호 중, 한번호가 다른 번호의 접두어인 경우가 있는지 확인
#
#조건 : 전화번호부에 적힌 전화번호 배열 배열 => phone_book
#       어떤 번호가 다른 번호의 접두어인 경우,, false반환
#       그렇지 않으면 true 반환
#
#예시 및 예시:          phone_book              return 
#       [119, 97674223, 1195524421]	 |    false
#       [123,456,789]	               |    true
#       [12,123,1235,567,88]	       |    false
#문제 예시 :
#   phone_book
# [ "456", "12", "1245"]
def solution(phone_book):
    p_b = sorted(phone_book)
    #sort = 정렬함수
    # 쓰임형태 : 리스트.sort() or  y = sorted(x) 형태
    # 리스트.sort() ==> 리스트 = [ 내용을 오름차순 정렬 ]
    # y = sorted(x) ==> x의 형태는 그대로 냅두는데, y에는 x의 [] 안의 값들을 정렬해서 저장시켜준다.
    # 
    # p_b = ["12", "1245", "456"] 

    #zip() 함수
    #동일한 개수로 이루어진 자료형을 묶어주는 역할
    #for s1, s2 in zip(a, b) 
    # ㄴs1은 a리스트에서 순서대로 값을 갖고오고, s2는 b에서 순서대로 값을 갖고오는 것이다.
    #
    #for문안에 p_b[1:] 에서 [1:]는 p_b에서 1번인덱스값부터 끝까지만 인식하겠다 의미이다.
    # 만약 [1: 5]라면,, 1번 인덱스부터 5번 인덱스까지만 인식하겠다가 된다. 
    # [1:]에서 [1:빈칸]처럼 빈칸이 들어가면,, 끝까지를 의미한다.
    # s1은 결국 p_b에서 0번째 인덱스부터 , s2는 p_b에서 1번째 인덱스부터 갖고오는 것이다. 

    for s1, s2 in zip(p_b, p_b[1:]): 
        #s1 = "12" ,  s2 = "1245"  을 갖고온 것이다.
        
        #s2.find(s1)은  s2문자열에 s1문자열이 속해있는지 확인하고,,
        #존재한다면,, 시작 인덱스값을 반환한다.
        #그래서 위 s1, s2상황이라면 s2 = "1245" 안에 s1 = "12" 가 
        #s2문자열에서 배열로 따지면 0번째부터 시작하는 것이기때문에 반환값을 0을 준 것이다.
        if s2.find(s1) == 0:
            return False 
    return True

